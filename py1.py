import pandas as pd
import numpy as np

# --- Configuration ---
INPUT_FILENAME = 'equal_coords_clean.csv'
OUTPUT_FILENAME = 'main.c'
CUTOFF_RATIO = 0.1
SCALE_K = 1.0  # Adjust this to change the size of the drawing
STEPS = 1000   # Number of points to draw for the shape

# -----------------------------------------------------------------------------
# This is the C code template for your STM32's main.c file.
# The '{coeffs_array}' and other placeholders will be filled in by the script.
# -----------------------------------------------------------------------------
C_CODE_TEMPLATE = """
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  * @author         : Generated by Python Script
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <math.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct {{
    int n;
    float real;
    float imag;
}} FourierCoefficient;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
DAC_HandleTypeDef hdac1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */

// --- Fourier coefficients generated for cutoff_ratio = {cutoff_ratio} ---
{coeffs_array}

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_DAC1_Init(void);
/* USER CODE BEGIN PFP */
void calculate_shape_point(float t, float k, float* x_out, float* y_out);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void calculate_shape_point(float t, float k, float* x_out, float* y_out) {{
    float x = 0.0f;
    float y = 0.0f;

    for (int i = 0; i < num_coeffs; i++) {{
        float c_real = coeffs[i].real;
        float c_imag = coeffs[i].imag;
        int n = coeffs[i].n;
        float angle = 2.0f * M_PI * n * t;

        x += c_real * cosf(angle) - c_imag * sinf(angle);
        y += c_real * sinf(angle) + c_imag * cosf(angle);
    }}

    *x_out = x * k;
    *y_out = y * k;
}}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{{
  /* USER CODE BEGIN 1 */
  const uint32_t dac_offset_x = {dac_offset_x};
  const uint32_t dac_offset_y = {dac_offset_y};
  const float scale_k = {scale_k}f;
  const int steps = {steps};
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_DAC1_Init();

  /* USER CODE BEGIN 2 */
  HAL_DAC_Start(&hdac1, DAC_CHANNEL_1);
  HAL_DAC_Start(&hdac1, DAC_CHANNEL_2);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {{
    /* USER CODE END WHILE */
    /* USER CODE BEGIN 3 */
    for (int i = 0; i < steps; i++) {{
        float t = (float)i / (float)steps;
        float x, y;

        calculate_shape_point(t, scale_k, &x, &y);

        uint32_t dac_x = dac_offset_x + (uint32_t)x;
        uint32_t dac_y = dac_offset_y + (uint32_t)y;

        if (dac_x > 4095) dac_x = 4095;
        if (dac_y > 4095) dac_y = 4095;

        HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dac_x);
        HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_2, DAC_ALIGN_12B_R, dac_y);
    }}
  }}
  /* USER CODE END 3 */
}}

// --- The rest are standard initialization functions ---

void SystemClock_Config(void) {{
  RCC_OscInitTypeDef RCC_OscInitStruct = {{0}};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {{0}};
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {{ Error_Handler(); }}
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) {{ Error_Handler(); }}
}}

static void MX_DAC1_Init(void) {{
  DAC_ChannelConfTypeDef sConfig = {{0}};
  hdac1.Instance = DAC1;
  if (HAL_DAC_Init(&hdac1) != HAL_OK) {{ Error_Handler(); }}
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK) {{ Error_Handler(); }}
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_2) != HAL_OK) {{ Error_Handler(); }}
}}

static void MX_USART2_UART_Init(void) {{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 38400;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK) {{ Error_Handler(); }}
}}

static void MX_GPIO_Init(void) {{
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
}}

void Error_Handler(void) {{
  __disable_irq();
  while (1) {{}}
}}

#ifdef USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line) {{}}
#endif
"""

def main():
    """Main function to process coordinates and generate C code."""
    print(f"Processing '{INPUT_FILENAME}' with cutoff ratio {CUTOFF_RATIO}...")

    # 1. Load and process coordinates
    try:
        df = pd.read_csv(INPUT_FILENAME, header=None, names=['x', 'y'])
    except FileNotFoundError:
        print(f"ERROR: Input file '{INPUT_FILENAME}' not found.")
        return

    x_mean = df['x'].mean()
    y_mean = df['y'].mean()
    z = (df['x'] - x_mean) + 1j * (df['y'] - y_mean)
    N = len(z)

    # 2. Calculate and filter FFT
    fft_coeffs = np.fft.fft(z) / N
    fft_coeffs_sorted = np.fft.fftshift(fft_coeffs)
    M = int(N * CUTOFF_RATIO * 0.5)

    zero_freq_index = N // 2
    start_index = zero_freq_index - M
    end_index = zero_freq_index + M + 1
    filtered_coeffs_vals = fft_coeffs_sorted[start_index:end_index]
    filtered_coeffs_n = np.arange(-M, M + 1)

    # 3. Generate the C code string for the coefficients array
    coeffs_c_code = "const FourierCoefficient coeffs[] = {\n"
    for n, c in zip(filtered_coeffs_n, filtered_coeffs_vals):
        if n == 0:
            continue
        if np.abs(c) > 1e-5:  # Filter out floating point noise
            coeffs_c_code += f"    {{{n}, {c.real:.4f}f, {c.imag:.4f}f}},\n"
    coeffs_c_code += "};\n"
    coeffs_c_code += f"const int num_coeffs = sizeof(coeffs) / sizeof(coeffs[0]);"

    # 4. Populate the C code template with the generated values
    final_c_code = C_CODE_TEMPLATE.format(
        coeffs_array=coeffs_c_code,
        dac_offset_x=int(x_mean),
        dac_offset_y=int(y_mean),
        cutoff_ratio=CUTOFF_RATIO,
        scale_k=SCALE_K,
        steps=STEPS
    )

    # 5. Write the final C code to the output file
    try:
        with open(OUTPUT_FILENAME, 'w') as f:
            f.write(final_c_code)
        print(f"\n✅ Success! The file '{OUTPUT_FILENAME}' has been created.")
        print("You can now open this file in STM32CubeIDE and flash it to your board.")
    except IOError as e:
        print(f"\n❌ Error: Could not write to file '{OUTPUT_FILENAME}'.\nReason: {e}")


if __name__ == '__main__':
    main()